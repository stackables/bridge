/**
 * Structured node reference — identifies a specific data point in the execution graph.
 *
 * Every wire has a "from" and "to", each described by a NodeRef.
 * The trunk (module + type + field + instance) identifies the node,
 * while path drills into its data.
 */
export type NodeRef = {
  /** Module identifier: "hereapi", "sendgrid", "zillow", or SELF_MODULE */
  module: string;
  /** GraphQL type ("Query" | "Mutation") or "Tools" for tool functions */
  type: string;
  /** Field or function name: "geocode", "search", "centsToUsd" */
  field: string;
  /** Instance number for tool calls (1, 2, ...) */
  instance?: number;
  /** References the current array element in a shadow tree (for per-element mapping) */
  element?: boolean;
  /** Path into the data: ["items", "0", "position", "lat"] */
  path: string[];
};

/**
 * A wire connects a data source (from) to a data sink (to).
 * Execution is pull-based: when "to" is demanded, "from" is resolved.
 *
 * Constant wires (`=`) set a fixed value on the target.
 * Pull wires (`<-`) resolve the source at runtime.
 * Pipe wires (`pipe: true`) are generated by the `<- h1:h2:source` shorthand
 * and route data through declared tool handles; the serializer collapses them
 * back to pipe notation.
 */
export type Wire =
  | { from: NodeRef; to: NodeRef; pipe?: true; force?: true; nullFallback?: string; fallback?: string; fallbackRef?: NodeRef }
  | { value: string; to: NodeRef };

/**
 * Bridge definition — wires one GraphQL field to its data sources.
 */
export type Bridge = {
  kind: "bridge";
  /** GraphQL type: "Query" | "Mutation" */
  type: string;
  /** GraphQL field name */
  field: string;
  /** Declared data sources and their wire handles */
  handles: HandleBinding[];
  /** Connection wires */
  wires: Wire[];
  /**
   * Pipe fork registry — one entry per pipe use.
   * Maps the fork's trunk key to the originating handle name and the base
   * trunk (used by the executor to inherit non-pipe bridge wires).
   */
  pipeHandles?: Array<{
    /** Unique trunk key for this fork: "module:type:field:instance" */
    key: string;
    /** The bridge handle name that was piped, e.g. "pt" or "convertToEur" */
    handle: string;
    /** Base trunk — regular (non-pipe) bridge wires targeting this trunk are
     *  applied to every fork before the fork-specific pipe wires. */
    baseTrunk: { module: string; type: string; field: string; instance?: number };
  }>;
};

/**
 * A handle binding — declares a named data source available in a bridge.
 *
 * Every wire reference in the bridge body must trace back to one of these.
 */
export type HandleBinding =
  | { handle: string; kind: "tool"; name: string }
  | { handle: string; kind: "input" }
  | { handle: string; kind: "output" }
  | { handle: string; kind: "context" }
  | { handle: string; kind: "const" };

/** Internal module identifier for the bridge's own trunk (input args + output fields) */
export const SELF_MODULE = "_";

/**
 * Tool definition — a declared tool with wires, dependencies, and optional inheritance.
 *
 * Tool blocks define reusable, composable API call configurations:
 *   tool hereapi httpCall        — root tool with function name
 *   tool hereapi.geocode extends hereapi  — child inherits parent wires
 *
 * The engine resolves extends chains, merges wires, and calls the
 * registered tool function with the fully-built input object.
 */
export type ToolDef = {
  kind: "tool";
  /** Tool name: "hereapi", "sendgrid.send", "authService" */
  name: string;
  /** Function name — looked up in the tools map. Omitted when extends is used. */
  fn?: string;
  /** Parent tool name — inherits fn, deps, and wires */
  extends?: string;
  /** Dependencies declared via `with` inside the tool block */
  deps: ToolDep[];
  /** Wires: constants (`=`) and pulls (`<-`) defining the tool's input */
  wires: ToolWire[];
};

/**
 * A dependency declared inside a tool block.
 *
 *   with context                 — brings the full GraphQL context into scope
 *   with authService as auth     — brings another tool's output into scope
 */
export type ToolDep =
  | { kind: "context"; handle: string }
  | { kind: "tool"; handle: string; tool: string }
  | { kind: "const"; handle: string };

/**
 * A wire in a tool block — either a constant value, a pull from a dependency,
 * or an error fallback.
 *
 * Examples:
 *   baseUrl = "https://api.sendgrid.com/v3"         → constant
 *   method = POST                                     → constant (unquoted)
 *   headers.Authorization <- ctx.sendgrid.token      → pull from context
 *   headers.Authorization <- auth.access_token       → pull from tool dep
 *   on error = { "lat": 0, "lon": 0 }               → constant fallback
 *   on error <- ctx.fallbacks.geo                     → pull fallback from context
 */
export type ToolWire =
  | { target: string; kind: "constant"; value: string }
  | { target: string; kind: "pull"; source: string }
  | { kind: "onError"; value: string }
  | { kind: "onError"; source: string };

/**
 * Tool call function — the signature for registered tool functions.
 *
 * Receives a fully-built nested input object and returns the response.
 * The engine builds the input from tool wires + bridge wires.
 *
 * Example (httpCall):
 *   input = { baseUrl: "https://...", method: "GET", path: "/geocode",
 *             headers: { apiKey: "..." }, q: "Berlin" }
 */
export type ToolCallFn = (
  input: Record<string, any>,
) => Promise<Record<string, any>>;

/**
 * Recursive tool map — supports namespaced tools via nesting.
 *
 * Example:
 *   { std: { upperCase, lowerCase }, httpCall: createHttpCall(), myCompany: { myTool } }
 *
 * Lookup is dot-separated: "std.upperCase" → tools.std.upperCase
 */
export type ToolMap = {
  [key: string]: ToolCallFn | ((...args: any[]) => any) | ToolMap;
};

/**
 * Named constant definition — a reusable value defined in the bridge file.
 *
 * Constants are available in bridge blocks via `with const as c` and in tool
 * blocks via `with const`. The engine collects all ConstDef instructions into
 * a single namespace object keyed by name.
 *
 * Examples:
 *   const fallbackGeo = { "lat": 0, "lon": 0 }
 *   const defaultCurrency = "EUR"
 */
export type ConstDef = {
  kind: "const";
  /** Constant name — used as the key in the const namespace */
  name: string;
  /** Raw JSON string — parsed at runtime when accessed */
  value: string;
};

/** Union of all instruction types */
export type Instruction = Bridge | ToolDef | ConstDef;

/**
 * Pluggable cache store for httpCall.
 *
 * Default: in-memory Map with TTL eviction.
 * Override: pass any key-value store (Redis, Memcached, etc.) to `createHttpCall`.
 *
 * ```ts
 * const httpCall = createHttpCall(fetch, myRedisStore);
 * ```
 */
export type CacheStore = {
  get(key: string): Promise<any | undefined> | any | undefined;
  set(key: string, value: any, ttlSeconds: number): Promise<void> | void;
};
